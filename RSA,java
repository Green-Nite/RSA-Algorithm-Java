/**
 * Inderjit Hothi
 * CSC-413-A
 * 12/05/2019
 * RSA Algorithm
 */

import java.math.*;
import java.util.Random;

public class RSA {
    public static void main(String[] args) {
        Random rnd = new Random();
        // P & Q need to be prime numbers that is generated by ProbablePrime
        BigInteger p = BigInteger.probablePrime(24, rnd);
        BigInteger q = BigInteger.probablePrime(24, rnd);
        BigInteger e = BigInteger.probablePrime(24, rnd);
        // N is P * Q
        BigInteger N = p.multiply(q);
        // Phi function is (P -1 )(Q - 1)
        BigInteger Phi = (p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE)));
        // Private Key is D
        // User takes the Public keys of the User which is N & E
        BigInteger D = dCalc(Phi, e);
        // Generating random number as our message
        int randomNumber = rnd.nextInt(200000);
        BigInteger message = new BigInteger(Integer.toString(randomNumber));
        System.out.println("Message that is being passed in : " + message);
        // The message is first encrypted with the two public keys n and e.
        BigInteger encryptedText = (encrypt(message, N, e));
        System.out.println("Message after it is Encrypted: " + encryptedText);
        // The other user would decrypted it with their private key which is d.
        System.out.println("Decrypting the message:  " + decrypt(encryptedText, D, N));
    }
    /* N:
        public static BigInteger NCalc(BigInteger p, BigInteger q) {
            BigInteger n;
            n = p.multiply(q);
            return n;
        }
    */

    /*
    public static BigInteger PhiCalc(BigInteger p, BigInteger q) {
        BigInteger Phi;
        BigInteger one = new BigInteger("1");
        Phi = (p.subtract(one)).multiply(q.subtract(one));
        return Phi;
    }
*/
    public static BigInteger dCalc(BigInteger phiVal, BigInteger eVal) {
        BigInteger d;
        //Choose an integer e, 1 < e < Phi, such that gcd(e,ϕ)=1.
        // Compute the secret exponent d, 1<d<ϕ, such that ed ≡ 1 mod ϕ.
        while (eVal.compareTo(phiVal) < 0 && phiVal.gcd(eVal).compareTo(BigInteger.ONE) > 0) {
            eVal.add(BigInteger.ONE);
        }
        d = eVal.modInverse(phiVal);
        return d;
    }
    public static BigInteger encrypt(BigInteger m, BigInteger nNum, BigInteger eNum) {
        BigInteger c;
        // Cipher Text = m^e mod n
        c = m.modPow(eNum, nNum);
        return c;
    }

    public static BigInteger decrypt(BigInteger c, BigInteger dNum, BigInteger nNum) {
        BigInteger DecryptedMessage;
        // Decryption : m = c^d mod n
        DecryptedMessage = (c.modPow(dNum, nNum));
        return DecryptedMessage;
    }
}
